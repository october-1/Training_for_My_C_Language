

# **指针**

![image-20210511191437242.png](https://github.com/october-1/Training_for_My_C_Language/blob/master/images/image-20210511191437242.png?raw=true)

通过i来访问或者改变这个值就叫做直接访问，如果通过p来进行访问或者改变就叫做(一级)间接访问；通过q叫做(二级)间接访问；

不论是几级指针，不管是什么类型的指针，指针在同一个平台大小是相同的；但是不能混用，因为取决于几个字节一读的这个方式，char或者int还有double都是不一样的。

```c
int *p = &i;
```

这里的类型是int*，名字是p。这个\*是跟着int走的，是一种整型形式就是整型的指针形式。

## 空指针：

​	int *p = NULL;

## 野指针：

​	当前的指针是没有指向的，就要使用；

## 空类型指针：*百搭的数据类型*

​	void *q = NULL;任何类型的指针值都可以吧自己的值赋给void\*，void\*也可以把自己的值赋值给任何类型的指针。

## 定义与初始化的书写规则：



## 指针运算：

​	&  *  关系运算  ++  --

## 指针与数组：

#### 	指针与一维数组			

```c
int a[3] = {1,2,3};
int *p = a;
a++; //这是一个错误的用法，a在这里是一个常量，不能放置于等号左侧，因为a++ <==> a = a + 1
p++; //这个操作可以，因为p是一个指针变量
//p+1和p++不一样，p++ <==> p = p + 1;但是p+1并没有这个赋值的过程，p本身并没有发生改变；
```

#### 指针与二维数组

###### ![image-20210511223921836.png](https://github.com/october-1/Training_for_My_C_Language/blob/master/images/image-20210511223921836.png?raw=true)	

当跳过一个数值，是跳过了很多数值就是在行上的移动，当跳过一个数值，只是跳过了一个元素，就是在列上移动；

a是a\[0][0]；a+1是a\[1][0];

a\[i][j]  <==>  \*（*(a+i)+j）

所以:

```c
int a[2][3] = {1,2,3,4,5,6};
int *p = *a;//其实等价于*p = *(a+0)
```

**?**为什么行取星就会降级，这个我先自己研究再说；

**！**原因就是其实*(a+j)就是跳到了应该取值的那个行，然后直接就在了a\[i][0]这个地址上，接下来只需要加上相对应的该行的第几列，就可以得到这个值的确切地址，然后用\*将其取出即可。

#### 指针与字符数组

```c
char str[] = "hello";
str = "world";//这是错误的，str是一个常量是不能在等号左边的
strcpy(str,"world");//这样才可以改变str的值
/*====================================================================*/
char *str = "hello";
sizeof(str) = 只针的大小
strlen(str) = 长度是正确答案
/*====================================================================*/
char *str = "hello";
//如果想改str的值，这次不能用strcpy了因为这时这个"hello"是一个串常量，是不能改变的 如果要改变可以:
str = "world";
```

要搞明白我们在操作的是空间还是指针；



定义数组时候马上定义指针，下面的工作用指针来完成；

## const与指针：

​	const 是一个非常重要的关键字

​	const是用来把某些内容常量化；	

​	【**注**】const定义的东西必须一旦定义就进行初始化，因为一旦定义就无法改变值。

##### 	int const a;

```c
define PI 3.14
//这样的话我就把所有的PI设定成了3.14，可以做到一改全改，可是问题在于，宏定义不检查语法；
```

```c
float pi = 3.14;
//这样可以检查语法但是pi是变量可以随意改变
```

```c
const float pi = 3.14;
//这样就可以检查语法了，pi也成为了一个常量
```

```c
const float pi = 3.14;
pi = 3.14159;//【错】因为const约束了pi现在pi是一个常量，不能进行改变；
```

**但是**

```c
const float pi = 3.14;
float *p = &pi;
*p = 3.14159;//这样是可以改变的，但是不合法
```

**上述做法是非常危险的**

```c
const float pi = 3.14;
const float *p = &pi;
*p = 3.14159;//这样是可以改变的，而且安全
```



##### 	const int *p;

##### 	int const *p;

​		这两个为常量指针，没有什么区别。

##### 	int *const p;

​		指针常量

##### 	const int *const p;

​		既是指针常量也是常量指针

​		既不可以改变指向的位置，也不可以改变*p的大小；

##### 先看到const就是常量指针，先看到*就是指针常量；const后面是指针\*指针名，就是为了保护这个指针不能变；\*在const前，后面跟着指针名，就是指向谁就是谁，方向不能变；

## 常量指针：

​	指针指向可以发生变化，但是指向的值不能变

```c
//常量指针：
int i = 1;
int j = 100;
int const *p = &i;
i = 10;//可以进行修改
*p = 10;//不可以进行修改
p = &j;//可以进行修改
//笼统来讲就是*p不能变，但是可以修改原值让*p发生改变，但是不能直接修改*p
```

## 指针常量：

​	指针值可以变化，但是指向不能改变 

```c
//指针常量:
int i = 1;
int jj = 100;
int *const p = &i;
i = 101;//可以改变*p的值
*p = 102;//可以改变*p的值
p = &j;//不可以改变指向方向
//笼统来说就是可以直接改变*p的值，但是，不能改变p指向的方向；
```

## 指针数组与数组指针：

#### 	数组指针：[存储类型]	数据类型	(*指针名)[下标]    =	值

​			如int (*p)[3];  -->  type name; -->  int[3] *p

## 多级指针：





## 

